/**
 * General API
 * TODO: Might need revamping, due to the nature of our app which accommodate privileges system
 * TODO: Might be a good idea to sanitize each request here, but how?
 *
 */

require("dotenv").config();
const { firebaseAdmin } = require("../services");
const { check } = require("../commons/helpers/jwt");
const { adminAuth } = firebaseAdmin;
const API_KEY = process.env.API_KEY || "12345";
const { resErrorHandler } = require("../commons/exceptions/resHandler");
const AuthenticationError = require("../commons/exceptions/AuthenticationError");
const AuthorizationError = require("../commons/exceptions/AuthorizationError");
const { decrypt } = require("../commons/helpers/crypt");
const setTokenIfrememberMe = require("../services/internal/setTokenIfrememberMe");
const getUpdatedUserInformation = require("../services/internal/getUpdatedUserInformation");

/**
 * firebaseMiddleware used to after-login routes that user first-time login to server after login from firebase (client)
 */
const firebaseMiddleware = (req, res, next) => {
  try {
    console.log("success hit endpoint 1/9");
    // access token value FB
    const authHeader = req.headers.authorization || "";
    const idToken = authHeader.startsWith("Bearer ")
      ? authHeader.substring(7, authHeader.length)
      : null;
    console.log("success check token 2/9");

    if (idToken) {
      adminAuth
        .auth()
        .verifyIdToken(idToken)
        .then((decodedToken) => {
          res.locals.uid = decodedToken.uid;
          console.log("success get verify token from firebase 3/9");
          return next();
        })
        .catch((error) => {
          console.log(error);
          return res.status(401).json({
            status: false,
            message: error.message,
          });
        });
    } else {
      throw new AuthenticationError();
    }
  } catch (error) {
    resErrorHandler(res, error);
  }
};

/**
 * kmsMiddleware used to checking jwt token that generated by smartkmsystem server from client, and assign user data information to res.locals
 * @param requiredPrivilege refers to tb_privilege -> privilege_code from group-service that required for bussiness model next controller, u can leave it with empty argument if next controller doesn't have bussiness models privilege required for logged in user
 * @param isPass identify the non privilege user gonna pass or not based required privilege
 */
const kmsMiddleware =
  (requiredPrivilege, isPass = false, role_codes = []) =>
  async (req, res, next) => {
    try {
      // access token value KMS
      const dataHeader =
        req?.headers?.["smartkmsystem-authorization"] ||
        req?.cookies?.smartkmsystemAuth ||
        "";
      let accessToken = dataHeader.startsWith("Bearer ")
        ? dataHeader.substring(7, dataHeader.length)
        : null;

      const setUserInformation = ({
        uid,
        group,
        user_id,
        role_code,
        employee_id,
        privileges,
        social_employee_profile_id,
      }) => {
        res.locals.uid = uid;
        res.locals.group = group;
        res.locals.user_id = user_id;
        res.locals.role_code = role_code;
        res.locals.employee_id = employee_id;
        res.locals.privileges = privileges;
        res.locals.social_employee_profile_id = social_employee_profile_id;
      };

      /** no cookies / accessToken */
      if (!accessToken) {
        /**
         * this block of statement was created for eksternal company apps (example: SAP) with api-key
         * or can interact to other services too (with api-key)
         */
        if (API_KEY === req.headers["api-key"]) {
          setUserInformation({
            uid: "SERVER",
            group: 0,
            user_id: 0,
            role_code: ["SERVER"],
            employee_id: 0,
            privileges: [],
          });
          return next();
        }

        if (!req.cookies.rememberMe) {
          throw new AuthenticationError("Invalid Token");
        }
        const rememberToken = JSON.parse(req.cookies.rememberMe);
        const decryptedUid = decrypt(rememberToken);
        const { jwt } = await setTokenIfrememberMe(res, decryptedUid, true);
        accessToken = jwt;
      }

      /** decode token then assign user information to res.locals */
      const decoded = check(accessToken);
      if (!decoded?.uid) {
        throw new AuthenticationError("Invalid Token: cannot parse uid");
      }

      const exp = decoded.exp;
      const diff = exp - Math.floor(Date.now() / 1000);

      if (diff <= 0) {
        throw new AuthenticationError("Token Expired");
      }

      /** get updated user information */
      const userUpdatedInformation = await getUpdatedUserInformation(
        decoded.user_id,
        requiredPrivilege
      );

      /** set loggedIn user information from decoded jwt */
      setUserInformation({
        uid: userUpdatedInformation.dataValues.uid,
        group: userUpdatedInformation?.employee?.dataValues?.group_id,
        user_id: userUpdatedInformation.dataValues.user_id,
        role_code: userUpdatedInformation?.role_code,
        employee_id: userUpdatedInformation?.employee?.dataValues?.employee_id,
        social_employee_profile_id:
          userUpdatedInformation?.employee?.social_employee_profile?.dataValues
            ?.social_employee_profile_id,
        privileges: userUpdatedInformation.privileges,
      });

      /** super admin pass before checking privileges */

      if (
        res.locals?.role_code?.some((role_code) =>
          role_codes?.includes(role_code)
        )
      ) {
        return next();
      }

      /** checking requiredPrivilege */
      if (requiredPrivilege) {
        if (!res.locals.privileges.includes(requiredPrivilege)) {
          if (!isPass) {
            throw new AuthorizationError(
              `required privilege code: ${requiredPrivilege}`
            );
          }
        } else {
          res.locals.hasPrivilege = true;
        }
      }

      /** user, sme, and managerial role with privilege pass */
      return next();
    } catch (error) {
      resErrorHandler(res, error);
    }
  };

module.exports = {
  firebaseMiddleware,
  kmsMiddleware,
};
